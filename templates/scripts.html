{{ define "scripts.html" }}
<script src="/static/js/uPlot.iife.min.js"></script>

<script>
    // Collapsible Logic
    var coll = document.getElementsByClassName("collapsible");
    var i;

    for (i = 0; i < coll.length; i++) {
        coll[i].addEventListener("click", function() {
            var clickedContent = this.nextElementSibling;
            var isCurrentlyOpen = this.classList.contains("active");

            // Close all collapsibles first
            for (var j = 0; j < coll.length; j++) {
                coll[j].classList.remove("active");
                var content = coll[j].nextElementSibling;
                content.style.maxHeight = null;
            }

            // If the clicked one wasn't open, open it
            if (!isCurrentlyOpen) {
                this.classList.add("active");
                clickedContent.style.maxHeight = clickedContent.scrollHeight + "px";
            }
        });
    }

    const SAMPLE_SIZE = 1024; // This is now just the default/max for time domain display if we want to keep it fixed, or we can make it match FFT_SIZE
    let FFT_SIZE = 1024;
    const RF_CHANNELS = [0,1,2,3,4,5,6,7];
    let peakTrackingEnabled = false;

    // Channel mapping: Software channel index -> {J connector}
    // Sequential order (CH1...CH8) corresponds to these J connectors
    const CHANNEL_J_MAP = [4, 7, 3, 8, 2, 5, 1, 6];

    function getChannelLabel(chIdx) {
        const jNum = CHANNEL_J_MAP[chIdx];
        return `J${jNum} - CH${chIdx + 1}`;
    }

    // Sweep state
    let sweepRunning = false;
    let sweepInterval = null;
    let currentSweepFreq = 0;

    // RF Configuration (fetched from backend)
    let CENTER_FREQ_MHZ = 125;
    let IBW_MHZ = 244.4;
    let FREQ_RES_MHZ = IBW_MHZ / FFT_SIZE;
    
    // Helper to get channel index from name (e.g., "I1" -> 0)
    function getRfChannel(name) { return parseInt(name.slice(1)) - 1; }

    // We still need this list for the Charts to map data correctly
    const COMPONENT_NAMES = [
        'I1', 'Q1', 'I2', 'Q2', 'I3', 'Q3', 'I4', 'Q4', 
        'I5', 'Q5', 'I6', 'Q6', 'I7', 'Q7', 'I8', 'Q8'
    ];
    
    let activeComponents = ['I1', 'Q1'];
    let ws;
    
    // --- Source Selection & Transport Logic ---
    let currentSourceMode = 'live'; // 'live' or 'replay'
    let isLiveStreaming = false;    // Tracks if live stream is "Started"
    let isReplaying = false;        // Tracks if replay is "Started"

    function switchSourceMode(mode) {
        currentSourceMode = mode;
        
        // Update Tabs
        const tabs = document.querySelectorAll('.source-tab');
        tabs.forEach(t => t.classList.remove('active'));
        const activeTab = document.querySelector(`.source-tab[onclick="switchSourceMode('${mode}')"]`);
        if(activeTab) activeTab.classList.add('active');

        // Update Content Visibility
        document.getElementById('live-controls').className = mode === 'live' ? 'tab-content-container active' : 'tab-content-container';
        document.getElementById('replay-controls').className = mode === 'replay' ? 'tab-content-container active' : 'tab-content-container';

        // If we switch modes, we should probably stop the "other" mode to avoid confusion
        // For now, let's just update the button state to reflect the current mode's status
        updateTransportButton();
        
        // Optional: Auto-stop previous mode if desired.
        // For safety, let's ensure we aren't trying to do both.
        if (mode === 'live') {
            // If we were replaying, stop it?
             if(isReplaying) toggleReplayMode(); 
        } else {
            // If we were streaming live, stop it?
             if(isLiveStreaming) toggleMainTransport(); // This toggles based on current mode, which is now replay.. wait.
             // We need to be careful. The toggle function uses currentSourceMode.
             // If we just switched 'currentSourceMode' to 'replay', calling toggleMainTransport() would try to toggle Replay.
             // We should manipulate the states directly via API if needed.
             if (isLiveStreaming) {
                 // Stop live stream manually
                 toggleLiveStream(false);
             }
        }
    }

    function updateTransportButton() {
        const btn = document.getElementById('transportBtn');
        if (currentSourceMode === 'live') {
            if (isLiveStreaming) {
                btn.innerText = "STOP LIVE STREAM";
                btn.className = "transport-btn btn-stop";
            } else {
                btn.innerText = "START LIVE STREAM";
                btn.className = "transport-btn btn-start";
            }
        } else {
            // Replay Mode
            if (isReplaying) {
                btn.innerText = "STOP RECORDING";
                btn.className = "transport-btn btn-stop";
            } else {
                btn.innerText = "PLAY RECORDING";
                btn.className = "transport-btn btn-start";
                // Disable play if no file selected?
                if (selectedReplayFile === '') {
                    btn.disabled = true;
                    btn.style.background = "#555";
                    btn.style.cursor = "not-allowed";
                } else {
                    btn.disabled = false;
                    btn.style.background = "#3cb44b"; // Reset to start color
                    btn.style.cursor = "pointer";
                }
            }
        }
    }

    function toggleMainTransport() {
        if (currentSourceMode === 'live') {
            toggleLiveStream(!isLiveStreaming);
        } else {
            toggleReplayMode();
        }
    }

    function toggleLiveStream(enable) {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        
        ws.send(JSON.stringify({
            type: "stream_control",
            enabled: enable
        }));
        
        // Optimistic update, actual state should come from server or we assume success
        isLiveStreaming = enable;
        updateTransportButton();
    }
    
    // --- UI Setup (Simplified to CH1-CH8) ---
    const cbContainer = document.getElementById('checkboxes');
    
        RF_CHANNELS.forEach(chIdx => {
            const label = document.createElement('label');
            label.style.color = getRandomColor(chIdx);
            const box = document.createElement('input');        box.type = 'checkbox';
        box.value = chIdx; // Value is 0, 1, 2...

        // Default: Check Channel 1 (index 0)
        box.checked = (chIdx === 0);
        box.onchange = updateConfig;

        label.appendChild(box);
        // Display with J number and Sharpie channel
        label.appendChild(document.createTextNode(` ${getChannelLabel(chIdx)}`));

        cbContainer.appendChild(label);
    });

    function togglePeakTracking() {
        peakTrackingEnabled = !peakTrackingEnabled;
        const btn = document.getElementById('peakToggle');
        const label = document.getElementById('peak-label');

        if (peakTrackingEnabled) {
            btn.innerText = "Disable Peak Tracking";
            btn.style.background = "#e6194b";
            label.style.display = "block";
        } else {
            btn.innerText = "Enable Peak Tracking";
            btn.style.background = "#555";
            label.style.display = "none";
        }
    }

    // Scale control functions
    function updateTimeScale() {
        if (!uplotTime) return;
        const xMin = parseFloat(document.getElementById('timeXMin').value);
        const xMax = parseFloat(document.getElementById('timeXMax').value);
        const yMin = parseFloat(document.getElementById('timeYMin').value);
        const yMax = parseFloat(document.getElementById('timeYMax').value);

        // Store the user-defined scales
        timeScaleX = { min: xMin, max: xMax };
        timeScaleY = { min: yMin, max: yMax };

        uplotTime.setScale('x', timeScaleX);
        uplotTime.setScale('y', timeScaleY);
    }

    function updateFFTScale() {
        if (!uplotFFT) return;
        const xMin = parseFloat(document.getElementById('fftXMin').value);
        const xMax = parseFloat(document.getElementById('fftXMax').value);
        const yMin = parseFloat(document.getElementById('fftYMin').value);
        const yMax = parseFloat(document.getElementById('fftYMax').value);

        // Store the user-defined scales
        fftScaleX = { min: xMin, max: xMax };
        fftScaleY = { min: yMin, max: yMax };

        uplotFFT.setScale('x', fftScaleX);
        uplotFFT.setScale('y', fftScaleY);
    }

    function resetTimeScale() {
        if (!uplotTime) return;
        const defaultXMin = 0;
        const defaultXMax = SAMPLE_SIZE;
        const defaultYMin = -2100;
        const defaultYMax = 2100;
        document.getElementById('timeXMin').value = defaultXMin;
        document.getElementById('timeXMax').value = defaultXMax;
        document.getElementById('timeYMin').value = defaultYMin;
        document.getElementById('timeYMax').value = defaultYMax;

        // Clear stored scales to use defaults
        timeScaleX = null;
        timeScaleY = null;

        uplotTime.setScale('x', { min: defaultXMin, max: defaultXMax });
        uplotTime.setScale('y', { min: defaultYMin, max: defaultYMax });
    }

    function resetFFTScale() {
        if (!uplotFFT) return;
        const minFreq = CENTER_FREQ_MHZ - (IBW_MHZ / 2);
        const maxFreq = CENTER_FREQ_MHZ + (IBW_MHZ / 2);
        const defaultYMin = -100;
        const defaultYMax = 5;
        document.getElementById('fftXMin').value = minFreq;
        document.getElementById('fftXMax').value = maxFreq;
        document.getElementById('fftYMin').value = defaultYMin;
        document.getElementById('fftYMax').value = defaultYMax;

        // Clear stored scales to use defaults
        fftScaleX = null;
        fftScaleY = null;

        uplotFFT.setScale('x', { min: minFreq, max: maxFreq });
        uplotFFT.setScale('y', { min: defaultYMin, max: defaultYMax });
    }

    function autoscaleTimeY() {
        if (!uplotTime || dataTime.length === 0) return;

        let globalMin = Infinity;
        let globalMax = -Infinity;

        // dataTime structure: [x_axis, ch1, ch2, ...]
        // Start from index 1 to skip X axis
        for (let i = 1; i < dataTime.length; i++) {
            const series = dataTime[i];
            if (!series) continue;
            
            // Check visibility
            const seriesOpts = uplotTime.series[i];
            if (!seriesOpts || !seriesOpts.show) continue;

            for (let j = 0; j < series.length; j++) {
                const val = series[j];
                if (val < globalMin) globalMin = val;
                if (val > globalMax) globalMax = val;
            }
        }

        if (globalMin === Infinity || globalMax === -Infinity) return;

        // Add 10% margin
        const range = globalMax - globalMin;
        const margin = range * 0.1 || 100; // Default margin if range is 0

        let newMin = globalMin - margin;
        let newMax = globalMax + margin;

        // Round nicely
        newMin = Math.floor(newMin);
        newMax = Math.ceil(newMax);

        document.getElementById('timeYMin').value = newMin;
        document.getElementById('timeYMax').value = newMax;

        timeScaleY = { min: newMin, max: newMax };
        uplotTime.setScale('y', timeScaleY);
    }

    function autoscaleFFTY() {
        if (!uplotFFT || dataFFT.length === 0) return;

        let globalMin = Infinity;
        let globalMax = -Infinity;

        // dataFFT structure: [x_axis, series1, series2...]
        for (let i = 1; i < dataFFT.length; i++) {
            const series = dataFFT[i];
            if (!series) continue;

            // Check visibility
            const seriesOpts = uplotFFT.series[i];
            if (!seriesOpts || !seriesOpts.show) continue;

            for (let j = 0; j < series.length; j++) {
                const val = series[j];
                // Ignore nulls and placeholders (like -150 initialization)
                if (val !== null && val > -140) {
                     if (val < globalMin) globalMin = val;
                     if (val > globalMax) globalMax = val;
                }
            }
        }

        if (globalMin === Infinity || globalMax === -Infinity) return;

        // Add 10% margin (in dB scale, usually adding static dB is better, but let's do range %)
        const range = globalMax - globalMin;
        const margin = range * 0.1 || 10; 

        let newMin = globalMin - margin;
        let newMax = globalMax + margin;
        
        // Round
        newMin = Math.floor(newMin);
        newMax = Math.ceil(newMax);

        document.getElementById('fftYMin').value = newMin;
        document.getElementById('fftYMax').value = newMax;

        fftScaleY = { min: newMin, max: newMax };
        uplotFFT.setScale('y', fftScaleY);
    }

    // --- Configuration Logic ---
    function updateConfig() {
        const boxes = cbContainer.querySelectorAll('input[type="checkbox"]');
        activeComponents = [];
        
        boxes.forEach(box => {
            if(box.checked) {
                const idx = parseInt(box.value) + 1;
                activeComponents.push(`I${idx}`);
                activeComponents.push(`Q${idx}`);
            }
        });

        const mode = document.getElementById('streamMode').value;
        const fps = document.getElementById('streamRate').value;
        const rbwSelect = document.getElementById('rbwSelect');
        
        // New FFT checkboxes
        const fftComplex = document.getElementById('fftComplex') ? document.getElementById('fftComplex').checked : true;
        const fftI = document.getElementById('fftI') ? document.getElementById('fftI').checked : false;
        const fftQ = document.getElementById('fftQ') ? document.getElementById('fftQ').checked : false;
        
        let fftTypes = [];
        if(fftComplex) fftTypes.push("complex");
        if(fftI) fftTypes.push("i");
        if(fftQ) fftTypes.push("q");
        
        // Check if FFT size changed
        const newFFTSize = parseInt(rbwSelect ? rbwSelect.value : 1024);
        const windowType = document.getElementById('windowSelect') ? document.getElementById('windowSelect').value : 'blackman';
        
        if (newFFTSize !== FFT_SIZE) {
            FFT_SIZE = newFFTSize;
            FREQ_RES_MHZ = IBW_MHZ / FFT_SIZE;
            // Force engine recreate or update
            if (fftEngine) {
                 fftEngine = new SimpleFFT(FFT_SIZE, windowType);
            }
        } else {
             // Size didn't change, but window might have
             if (fftEngine) {
                 fftEngine.setWindowType(windowType);
             }
        }

        setupCharts(); 

        if (ws && ws.readyState === WebSocket.OPEN) {
            const payload = {
                channels: activeComponents,
                mode: mode,
                fps: parseInt(fps),
                fft_size: FFT_SIZE, // Send updated FFT size
                fft_types: fftTypes
            };
            ws.send(JSON.stringify(payload));
        }
    }

    // --- uPlot Instances ---
    let uplotTime, uplotFFT;
    let dataTime = [], dataFFT = [];

    // Store user-defined scale ranges
    let timeScaleX = null;
    let timeScaleY = null;
    let fftScaleX = null;
    let fftScaleY = null;

    function getRandomColor(idx) {
        const colors = ["#e6194b", "#3cb44b", "#ffe119", "#4363d8", "#f58231", "#911eb4", "#46f0f0", "#f032e6"];
        return colors[idx % colors.length];
    }

    function getChartWidth() {
        const container = document.querySelector('.main-content');
        return container ? container.clientWidth - 40 : window.innerWidth - 60;
    }

    function setupCharts() {
        if (uplotTime) { uplotTime.destroy(); uplotTime = null; }
        if (uplotFFT) { uplotFFT.destroy(); uplotFFT = null; }

        document.getElementById('chart-time').innerHTML = '';
        document.getElementById('chart-fft').innerHTML = '';

        const mode = document.getElementById('streamMode').value;
        const showRaw = (mode === 'raw' || mode === 'both');
        const showFFT = (mode === 'fft' || mode === 'both');

        const width = getChartWidth();

        if (showRaw) {
            const xTime = Array.from({length: SAMPLE_SIZE}, (_, i) => i);
            dataTime = [xTime];
            const seriesTime = [{ label: "Time" }];

            COMPONENT_NAMES.forEach((name, i) => {
                dataTime.push(new Array(SAMPLE_SIZE).fill(0));
                const isActive = activeComponents.includes(name);
                seriesTime.push({
                    label: name, stroke: getRandomColor(getRfChannel(name)),
                    width: 1, show: isActive
                });
            });

            uplotTime = new uPlot({
                width: width, height: 300,
                scales: {
                    // CHANGE 1: Use functions for range to check global overrides
                    x: {
                        time: false,
                        range: (u, min, max) => timeScaleX ? [timeScaleX.min, timeScaleX.max] : [0, SAMPLE_SIZE]
                    },
                    y: {
                        range: (u, min, max) => timeScaleY ? [timeScaleY.min, timeScaleY.max] : [-12000, 12000]
                    }
                },
                axes: [
                    { label: "Sample Index", labelSize: 20, stroke: "#ccc", grid: { show: true, stroke: "#444", width: 1, dash: [5, 5] } },
                    { label: "Amplitude (ADC counts)", labelSize: 20, stroke: "#ccc", space: 40, grid: { show: true, stroke: "#444", width: 1, dash: [5, 5] } }
                ],
                series: seriesTime
            }, dataTime, document.getElementById('chart-time'));
        }

        if (showFFT) {
            const xFFT = Array.from({length: FFT_SIZE}, (_, i) => {
                const bin = i - FFT_SIZE/2;
                return CENTER_FREQ_MHZ + (bin * FREQ_RES_MHZ);
            });
            dataFFT = [xFFT];
            const seriesFFT = [{ label: "Frequency (MHz)" }];
            
            const fftComplex = document.getElementById('fftComplex') ? document.getElementById('fftComplex').checked : true;
            const fftI = document.getElementById('fftI') ? document.getElementById('fftI').checked : false;
            const fftQ = document.getElementById('fftQ') ? document.getElementById('fftQ').checked : false;

            // 1. Complex Traces (Indices 1-8)
            RF_CHANNELS.forEach(ch => {
                dataFFT.push(new Array(FFT_SIZE).fill(-150));
                const isActive = activeComponents.includes(`I${ch+1}`) || activeComponents.includes(`Q${ch+1}`);
                seriesFFT.push({
                    label: getChannelLabel(ch) + " (C)", stroke: getRandomColor(ch),
                    width: 2, show: isActive && fftComplex
                });
            });
            
            // 2. I-Only Traces (Indices 9-16)
            RF_CHANNELS.forEach(ch => {
                dataFFT.push(new Array(FFT_SIZE).fill(-150));
                const isActive = activeComponents.includes(`I${ch+1}`) || activeComponents.includes(`Q${ch+1}`);
                seriesFFT.push({
                    label: getChannelLabel(ch) + " (I)", stroke: getRandomColor(ch),
                    width: 1, show: isActive && fftI, dash: [5, 5]
                });
            });
            
            // 3. Q-Only Traces (Indices 17-24)
            RF_CHANNELS.forEach(ch => {
                dataFFT.push(new Array(FFT_SIZE).fill(-150));
                const isActive = activeComponents.includes(`I${ch+1}`) || activeComponents.includes(`Q${ch+1}`);
                seriesFFT.push({
                    label: getChannelLabel(ch) + " (Q)", stroke: getRandomColor(ch),
                    width: 1, show: isActive && fftQ, dash: [2, 2]
                });
            });

            // 4. Peaks (Indices 25-32) - Only for Complex
            RF_CHANNELS.forEach(ch => {
                dataFFT.push(new Array(FFT_SIZE).fill(null));
                seriesFFT.push({
                    label: `Peak ${getChannelLabel(ch)}`, stroke: getRandomColor(ch),
                    fill: "white", width: 2,
                    paths: uPlot.paths.points({size: 8}),
                    show: true, display: false
                });
            });

            const minFreq = CENTER_FREQ_MHZ - (IBW_MHZ / 2);
            const maxFreq = CENTER_FREQ_MHZ + (IBW_MHZ / 2);

            uplotFFT = new uPlot({
                width: width, height: 500,
                scales: {
                    // CHANGE 2: Use functions for FFT range as well
                    x: {
                        time: false,
                        range: (u, min, max) => fftScaleX ? [fftScaleX.min, fftScaleX.max] : [minFreq, maxFreq]
                    },
                    y: {
                        range: (u, min, max) => fftScaleY ? [fftScaleY.min, fftScaleY.max] : [-100, 5]
                    }
                },
                axes: [
                    { label: "Frequency (MHz)", stroke: "#ccc", values: (self, splits) => splits.map(v => v.toFixed(1)), grid: { show: true, stroke: "#444", width: 1, dash: [5, 5] } },
                    { label: "Power (dBm)", stroke: "#ccc", space: 40, grid: { show: true, stroke: "#444", width: 1, dash: [5, 5] } }
                ],
                series: seriesFFT,
                cursor: { focus: { prox: 5 } }
            }, dataFFT, document.getElementById('chart-fft'));
        }
    }
    // --- FFT Implementation (Simple Radix-2) ---
    class SimpleFFT {
        constructor(size, windowType = 'blackman') {
            this.size = size;
            this.windowType = windowType;
            this.reverseTable = new Uint32Array(size);
            let limit = 1;
            let bit = size >> 1;
            while (limit < size) {
                for (let i = 0; i < limit; i++) {
                    this.reverseTable[i + limit] = this.reverseTable[i] + bit;
                }
                limit <<= 1;
                bit >>= 1;
            }

            this.sinTable = new Float64Array(size);
            this.cosTable = new Float64Array(size);
            for (let i = 0; i < size; i++) {
                this.sinTable[i] = Math.sin(-2 * Math.PI * i / size);
                this.cosTable[i] = Math.cos(-2 * Math.PI * i / size);
            }
            
            this.calculateWindow();
        }

        calculateWindow() {
            this.window = new Float64Array(this.size);
            this.windowSum = 0;
            const N = this.size;
            
            for(let i=0; i<N; i++) {
                let val = 1.0;
                switch(this.windowType) {
                    case 'rectangular':
                        val = 1.0;
                        break;
                    case 'hamming':
                        val = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (N - 1));
                        break;
                    case 'hanning':
                        val = 0.5 * (1 - Math.cos(2 * Math.PI * i / (N - 1)));
                        break;
                    case 'flattop':
                        val = 0.21557895 - 0.41663158 * Math.cos(2 * Math.PI * i / (N - 1)) + 
                              0.277263158 * Math.cos(4 * Math.PI * i / (N - 1)) - 
                              0.083578947 * Math.cos(6 * Math.PI * i / (N - 1)) + 
                              0.006947368 * Math.cos(8 * Math.PI * i / (N - 1));
                        break;
                    case 'blackman':
                    default:
                        val = 0.42 - 0.5 * Math.cos(2 * Math.PI * i / (N - 1)) + 0.08 * Math.cos(4 * Math.PI * i / (N - 1));
                        break;
                }
                this.window[i] = val;
                this.windowSum += val;
            }
        }
        
        setWindowType(type) {
            if (this.windowType !== type) {
                this.windowType = type;
                this.calculateWindow();
            }
        }

        transform(real, imag) {
            // Bit-reverse copy
            const n = this.size;
            const rev = this.reverseTable;
            const r = new Float64Array(n);
            const i = new Float64Array(n);

            for(let j=0; j<n; j++) {
                let k = rev[j];
                // Apply window during copy
                r[j] = real[k] * this.window[k];
                i[j] = imag[k] * this.window[k];
            }

            // Cooley-Tukey
            let halfSize = 1;
            while (halfSize < n) {
                const phaseStep = n / (halfSize * 2);
                for (let k = 0; k < halfSize; k++) {
                    const phase = k * phaseStep; // index into sin/cos table
                    // phase is integer here because table is size N
                    // Wait, table size is N. phaseStep = N/2, N/4...
                    // k goes 0..halfSize-1. k*phaseStep goes 0..N/2-something.
                    // Correct index is k * (n / (halfSize*2)) -> k * n / size
                    const tableIdx = k * (n / (halfSize * 2));
                    
                    const c = this.cosTable[tableIdx];
                    const s = this.sinTable[tableIdx];

                    for (let j = k; j < n; j += halfSize * 2) {
                        const next = j + halfSize;
                        const tr = r[next] * c - i[next] * s;
                        const ti = r[next] * s + i[next] * c;

                        r[next] = r[j] - tr;
                        i[next] = i[j] - ti;
                        r[j] = r[j] + tr;
                        i[j] = i[j] + ti;
                    }
                }
                halfSize <<= 1;
            }
            return { real: r, imag: i };
        }
        
        calculateDBm(real, imag) {
            const out = new Float64Array(this.size);
            const half = this.size / 2;
            const fullScaleAmp = 13500.0;  // 16-bit ADC: 2^15
            const fullScaleDBm = 3.9;      // Full scale input power
            
            // For power normalization, we should divide by the sum of window values (Coherent Gain)
            // But usually for spectral density we might use energy gain (sum of squares).
            // For pure amplitude accuracy of peaks, divide by Coherent Gain (sum of window).
            // Let's stick with windowSum which acts as the Coherent Gain.
            const ref = fullScaleAmp * this.windowSum;
            
            for(let i=0; i<this.size; i++) {
                // FFT Shift: i maps to (i + half) % size
                const idx = (i + half) % this.size;
                const mag = Math.sqrt(real[idx]*real[idx] + imag[idx]*imag[idx]);
                
                if (mag > 0) {
                    // Multiply by 2 because we discard negative frequencies in real-valued FFTs?
                    // No, this is complex FFT.
                    // But maybe we need to account for power being split or window loss.
                    // Let's keep existing logic: 20*log10(mag / ref) + offset.
                    out[i] = 20 * Math.log10(mag / ref) + fullScaleDBm;
                } else {
                    out[i] = -150.0;
                }
            }
            return out;
        }
    }

    let fftEngine = null;

    // Performance Stats
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let lastFpsUpdate = 0;
    let accumulatedProcessTime = 0;
    let accumulatedFFTTime = 0;

    function parseAndPlot(arrayBuffer) {
        const startTotal = performance.now();
        
        // Calculate FPS
        frameCount++;
        const now = performance.now();
        if (now - lastFpsUpdate >= 1000) {
            const fps = frameCount * 1000 / (now - lastFpsUpdate);
            document.getElementById('perfFPS').innerText = fps.toFixed(1);
            
            // Average times
            const avgProcess = accumulatedProcessTime / frameCount;
            const avgFFT = accumulatedFFTTime / frameCount;
            document.getElementById('perfProcess').innerText = avgProcess.toFixed(2) + " ms";
            document.getElementById('perfFFT').innerText = avgFFT.toFixed(2) + " ms";

            // Reset
            frameCount = 0;
            lastFpsUpdate = now;
            accumulatedProcessTime = 0;
            accumulatedFFTTime = 0;
        }

        const view = new DataView(arrayBuffer);
        let offset = 0;
        
        // We receive raw I/Q channels. Packet structure: Header (1 byte) + Data (2 * N bytes).
        // N is variable now (samplesNeeded from server).
        // We need to parse until end of buffer.
        
        // Buffers for I and Q channels to hold the current frame's data
        // Reset them? No, we just read them.
        
        // 8 Channels max
        let channelDataI = new Array(8).fill(null);
        let channelDataQ = new Array(8).fill(null);
        
        while (offset < arrayBuffer.byteLength) {
            if (offset + 1 > arrayBuffer.byteLength) break;
            const headerID = view.getUint8(offset);
            offset += 1;
            
            // Header: 0..15
            // Ch = header >> 1. Component = header & 1 (0=I, 1=Q)
            const ch = headerID >> 1;
            const isQ = (headerID & 1) === 1;
            
            // Determine length. We assume the rest of the buffer is divided equally? 
            // Or we check how many bytes are left?
            // Actually, the protocol streams multiple chunks.
            // But wait, the server code does:
            // for ch: append header, append data.
            // So we know the data length? The server sends `samplesNeeded`.
            // But the client doesn't know `samplesNeeded` implicitly unless we infer or fix it.
            // However, previous code assumed fixed BYTES_TIME or BYTES_FFT.
            // Now `samplesNeeded` depends on FFT_SIZE.
            // The client knows FFT_SIZE.
            // Let's assume the server sent `max(SAMPLE_SIZE, FFT_SIZE)` points.
            // Actually, server sends `samplesNeeded`.
            
            // NOTE: Robust parsing would need a length header. 
            // But since we control both, we know the Server uses `samplesNeeded`.
            // Client's `FFT_SIZE` should match Server's.
            // Let's rely on that.
            
            const points = FFT_SIZE >= SAMPLE_SIZE ? FFT_SIZE : SAMPLE_SIZE;
            const bytesLen = points * 2;
            
            if (offset + bytesLen <= arrayBuffer.byteLength) {
                const slice = arrayBuffer.slice(offset, offset + bytesLen);
                const arr = new Int16Array(slice);
                
                if (ch < 8) {
                    if (isQ) channelDataQ[ch] = arr;
                    else channelDataI[ch] = arr;
                }
                offset += bytesLen;
            } else {
                // Not enough bytes? Break.
                break;
            }
        }
        
        // Update Time Plots
        if (uplotTime) {
            // Need to map channelDataI/Q to dataTime array
            // dataTime[0] is x-axis (already set)
            // indices: 
            // I0->1, Q0->2, I1->3, Q1->4 ...
            // Component Name Map: I0, Q0, I1, Q1 ... 
            
            for(let ch=0; ch<8; ch++) {
                if (channelDataI[ch]) {
                    // Take first SAMPLE_SIZE points
                    dataTime[ch*2 + 1] = channelDataI[ch].subarray(0, SAMPLE_SIZE);
                }
                if (channelDataQ[ch]) {
                    dataTime[ch*2 + 2] = channelDataQ[ch].subarray(0, SAMPLE_SIZE);
                }
            }
            uplotTime.setData(dataTime);
        }
        
        // Update FFT Plots
        let startFFT = performance.now(); // Start FFT timer
        if (uplotFFT) {
            // Check Engine
            const windowType = document.getElementById('windowSelect') ? document.getElementById('windowSelect').value : 'blackman';
            if (!fftEngine || fftEngine.size !== FFT_SIZE) {
                fftEngine = new SimpleFFT(FFT_SIZE, windowType);
            }
            
            const fftComplex = document.getElementById('fftComplex') ? document.getElementById('fftComplex').checked : true;
            const fftI = document.getElementById('fftI') ? document.getElementById('fftI').checked : false;
            const fftQ = document.getElementById('fftQ') ? document.getElementById('fftQ').checked : false;

            let channelPeaks = {};
            
            for(let ch=0; ch<8; ch++) {
                const iData = channelDataI[ch];
                const qData = channelDataQ[ch];
                
                // Only process if we have data
                if (!iData && !qData) continue;
                
                // Prepare inputs (pad with 0 if missing)
                // We need Float64 for FFT
                const iIn = new Float64Array(FFT_SIZE);
                const qIn = new Float64Array(FFT_SIZE);
                
                if (iData) {
                    for(let k=0; k<FFT_SIZE && k<iData.length; k++) iIn[k] = iData[k];
                }
                if (qData) {
                    for(let k=0; k<FFT_SIZE && k<qData.length; k++) qIn[k] = qData[k];
                }
                
                // 1. Complex FFT: I + jQ
                if (fftComplex) {
                    const res = fftEngine.transform(iIn, qIn);
                    const db = fftEngine.calculateDBm(res.real, res.imag);
                    
                    // Update trace (Indices 1-8 are Complex traces)
                    dataFFT[ch + 1] = db;
                    
                    // Peak Tracking
                    if (peakTrackingEnabled) {
                        let localMax = -9999;
                        let localIdx = 0;
                        for(let k=0; k<db.length; k++) {
                            if(db[k] > localMax) {
                                localMax = db[k];
                                localIdx = k;
                            }
                        }
                        
                        // Peaks are indices 25-32
                        const markerArr = new Array(FFT_SIZE).fill(null);
                        markerArr[localIdx] = localMax;
                        dataFFT[25 + ch] = markerArr;
                        
                        const bin = localIdx - (FFT_SIZE / 2);
                        const freqMHz = CENTER_FREQ_MHZ + (bin * FREQ_RES_MHZ);
                        channelPeaks[ch + 1] = { db: localMax, freqMHz: freqMHz };
                    } else {
                         dataFFT[25 + ch] = new Array(FFT_SIZE).fill(null);
                    }
                }
                
                // 2. I-Only FFT: I + j0
                if (fftI) {
                    // Reuse qIn as zeros? No, qIn might have Q data. Need zeros.
                    const zeros = new Float64Array(FFT_SIZE);
                    const res = fftEngine.transform(iIn, zeros);
                    const db = fftEngine.calculateDBm(res.real, res.imag);
                    // Indices 9-16
                    dataFFT[9 + ch] = db;
                }
                
                // 3. Q-Only FFT: Q + j0
                if (fftQ) {
                    const zeros = new Float64Array(FFT_SIZE);
                    const res = fftEngine.transform(qIn, zeros);
                    const db = fftEngine.calculateDBm(res.real, res.imag);
                    // Indices 17-24
                    dataFFT[17 + ch] = db;
                }
            }
            
            uplotFFT.setData(dataFFT);
            
            // Update Labels
            const labelEl = document.getElementById('peak-label');
            if (peakTrackingEnabled) {
                let html = `<div style="color:#aaa; font-size:11px; margin-bottom:5px;">CHANNEL         POWER       FREQUENCY</div>`;
                for(let i = 1; i <= 8; i++) {
                    if (channelPeaks[i]) {
                        const peak = channelPeaks[i];
                        const freqStr = peak.freqMHz.toFixed(3);
                        const chLabel = getChannelLabel(i - 1);
                        const color = getRandomColor(i - 1);
                        html += `
                        <div class="peak-row">
                            <span class="peak-ch" style="color: ${color}">${chLabel}</span>
                            <span class="peak-db">${peak.db.toFixed(2)} dB</span>
                            <span class="peak-bin">${freqStr} MHz</span>
                        </div>`;
                    }
                }
                labelEl.innerHTML = html;
            }
        }
        accumulatedFFTTime += (performance.now() - startFFT);
        accumulatedProcessTime += (performance.now() - startTotal);
    }

    // Fetch RF configuration from backend
    async function fetchRFConfig() {
        try {
            const response = await fetch('/api/rf/config');
            const config = await response.json();

            // Use DDC frequency as the center frequency
            CENTER_FREQ_MHZ = config.ddc_freq_mhz;
            IBW_MHZ = config.ibw_mhz;
            FREQ_RES_MHZ = IBW_MHZ / FFT_SIZE;

            console.log(`RF Config: Center=${CENTER_FREQ_MHZ} MHz, IBW=${IBW_MHZ} MHz, DDC=${config.ddc_freq_mhz} MHz, Res=${FREQ_RES_MHZ.toFixed(6)} MHz/bin`);

            // Update FFT X-axis input fields with correct frequency range
            const minFreq = CENTER_FREQ_MHZ - (IBW_MHZ / 2);
            const maxFreq = CENTER_FREQ_MHZ + (IBW_MHZ / 2);
            document.getElementById('fftXMin').value = minFreq;
            document.getElementById('fftXMax').value = maxFreq;

            // Refresh charts with new frequency scale
            if (uplotFFT) {
                setupCharts();
            }
        } catch (error) {
            console.error('Failed to fetch RF config:', error);
        }
    }

    // Update Signal Generator frequency
    async function updateSigGenFrequency() {
        const freqInput = document.getElementById('sigGenFreqInput');
        const statusEl = document.getElementById('sigGenStatus');
        const freq = parseFloat(freqInput.value);

        statusEl.innerText = 'Updating...';
        statusEl.style.color = 'yellow';

        try {
            const response = await fetch('/api/siggen/frequency', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ freq_mhz: freq })
            });

            const data = await response.json();

            if (response.ok && data.success) {
                statusEl.innerText = `✓ SigGen set to ${data.freq_mhz} MHz`;
                statusEl.style.color = '#3cb44b';
                setTimeout(() => { statusEl.innerText = ''; }, 3000);
            } else {
                statusEl.innerText = `✗ Error: ${data.error || 'Failed'}`;
                statusEl.style.color = '#e6194b';
            }
        } catch (error) {
            statusEl.innerText = `✗ Error: ${error.message}`;
            statusEl.style.color = '#e6194b';
            console.error('Failed to update signal generator frequency:', error);
        }
    }

    async function updateSigGenPower() {
        const powerInput = document.getElementById('sigGenPowerInput');
        const statusEl = document.getElementById('sigGenPowerStatus');
        const power = parseFloat(powerInput.value);

        statusEl.innerText = 'Updating...';
        statusEl.style.color = 'yellow';

        try {
            const response = await fetch('/api/siggen/power', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ power_dbm: power })
            });

            const data = await response.json();

            if (response.ok && data.success) {
                statusEl.innerText = `✓ ${data.power_dbm} dBm`;
                statusEl.style.color = '#3cb44b';
                setTimeout(() => { statusEl.innerText = ''; }, 3000);
            } else {
                statusEl.innerText = `✗ Error`;
                statusEl.style.color = '#e6194b';
            }
        } catch (error) {
            statusEl.innerText = `✗ Error`;
            statusEl.style.color = '#e6194b';
            console.error('Failed to update signal generator power:', error);
        }
    }

    async function toggleSigGenOutput() {
        const btn = document.getElementById('sigGenToggle');
        const isCurrentlyOn = btn.innerText.includes("ON");
        const newState = !isCurrentlyOn;

        try {
            const response = await fetch('/api/siggen/output', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: newState })
            });
            
            if (response.ok) {
                // Update UI immediately (though websocket will also push)
                if (newState) {
                    btn.innerText = "RF Output: ON";
                    btn.className = "btn-success";
                } else {
                    btn.innerText = "RF Output: OFF";
                    btn.className = "btn-danger";
                }
            }
        } catch (error) {
            console.error('Failed to toggle SigGen output:', error);
        }
    }

    // Remove setSigGenFrequencyQuiet as it's no longer needed in client

    function toggleSweep() {
        if (sweepRunning) {
            stopSweep();
        } else {
            startSweep();
        }
    }

    async function startSweep() {
        const startFreq = parseFloat(document.getElementById('sweepStart').value);
        const stopFreq = parseFloat(document.getElementById('sweepStop').value);
        const stepFreq = parseFloat(document.getElementById('sweepStep').value);
        const dwellTime = parseFloat(document.getElementById('sweepDwell').value);

        if (startFreq >= stopFreq) { alert('Start < Stop required'); return; }
        if (stepFreq <= 0) { alert('Step > 0 required'); return; }
        if (dwellTime < 10) { alert('Dwell >= 10ms required'); return; }

        try {
            const response = await fetch('/api/sweep/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    start_mhz: startFreq,
                    stop_mhz: stopFreq,
                    step_mhz: stepFreq,
                    dwell_ms: dwellTime
                })
            });
            // The WebSocket message will update the UI state
        } catch (error) {
            console.error('Failed to start sweep:', error);
        }
    }

    async function stopSweep() {
        try {
            await fetch('/api/sweep/stop', { method: 'POST' });
            // The WebSocket message will update the UI state
        } catch (error) {
            console.error('Failed to stop sweep:', error);
        }
    }

    function setSweepRunningState(isRunning) {
        sweepRunning = isRunning;
        const sweepBtn = document.getElementById('sweepBtn');
        const statusEl = document.getElementById('sweepStatus');
        
        const inputs = ['sweepStart', 'sweepStop', 'sweepStep', 'sweepDwell'];

        if (isRunning) {
            sweepBtn.innerText = 'Stop Sweep';
            sweepBtn.className = 'btn-danger';
            inputs.forEach(id => document.getElementById(id).disabled = true);
        } else {
            sweepBtn.innerText = 'Start Sweep';
            sweepBtn.className = 'btn-success';
            inputs.forEach(id => document.getElementById(id).disabled = false);
            statusEl.innerText = 'Sweep stopped';
            statusEl.style.color = '#aaa';
            setTimeout(() => { statusEl.innerText = ''; }, 3000);
        }
    }
    
    async function fetchSweepState() {
         try {
            const response = await fetch('/api/sweep/state');
            const data = await response.json();
            if (data.running) {
                setSweepRunningState(true);
                if (data.params) {
                     document.getElementById('sweepStart').value = data.params.start_mhz;
                     document.getElementById('sweepStop').value = data.params.stop_mhz;
                     document.getElementById('sweepStep').value = data.params.step_mhz;
                     document.getElementById('sweepDwell').value = data.params.dwell_ms;
                }
            }
        } catch (error) {
            console.error('Failed to fetch sweep state:', error);
        }
    }

    // Fetch and populate signal generator state
    async function fetchSigGenState() {
        try {
            const response = await fetch('/api/siggen/state');
            const data = await response.json();
            if (data.freq_mhz !== undefined) {
                document.getElementById('sigGenFreqInput').value = data.freq_mhz;
            }
            if (data.power_dbm !== undefined) {
                document.getElementById('sigGenPowerInput').value = data.power_dbm;
            }
            if (data.rf_output !== undefined) {
                const btn = document.getElementById('sigGenToggle');
                if (data.rf_output) {
                    btn.innerText = "RF Output: ON";
                    btn.className = "btn-success";
                } else {
                    btn.innerText = "RF Output: OFF";
                    btn.className = "btn-danger";
                }
            }
        } catch (error) {
            console.error('Failed to fetch signal generator state:', error);
        }
    }

    // --- PSU Logic ---
    async function fetchPSUState() {
        try {
            const response = await fetch('/api/psu/state');
            if (!response.ok) return; // Silent fail on error to avoid log spam
            
            const data = await response.json();
            if (data.outputs && data.outputs.length >= 2) { // Index 1 is Channel 2
                const ch2 = data.outputs[1]; 
                
                const volt = ch2.measured_voltage;
                const curr = ch2.measured_current;
                const power = volt * curr;
                const enabled = ch2.enabled;

                document.getElementById('psu2Volt').innerText = volt.toFixed(3) + " V";
                document.getElementById('psu2Curr').innerText = curr.toFixed(3) + " A";
                document.getElementById('psu2Power').innerText = power.toFixed(3) + " W";

                const btn = document.getElementById('psu2Toggle');
                if (enabled) {
                    btn.innerText = "ON";
                    btn.className = "btn-success";
                } else {
                    btn.innerText = "OFF";
                    btn.className = "btn-danger";
                }
            }
        } catch (error) {
            // Console log occasionally useful but can spam
            // console.error('Failed to fetch PSU state:', error);
        }
    }

    async function togglePSU2() {
        const btn = document.getElementById('psu2Toggle');
        const isCurrentlyOn = btn.innerText === "ON";
        const newState = !isCurrentlyOn;

        try {
            const response = await fetch('/api/psu/output/2/enable', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: newState })
            });
            
            if (response.ok) {
                // Update UI immediately for responsiveness, though the polling will also catch it
                if (newState) {
                    btn.innerText = "ON";
                    btn.className = "btn-success";
                } else {
                    btn.innerText = "OFF";
                    btn.className = "btn-danger";
                }
            }
        } catch (error) {
            console.error('Failed to toggle PSU:', error);
            alert('Failed to toggle PSU Channel 2');
        }
    }

    // --- Hardware Control Logic ---
    async function updateHWDDCFrequency(ddcIndex) {
        const freqInput = document.getElementById(`ddc${ddcIndex}FreqInput`);
        const freq = parseFloat(freqInput.value);

        try {
            const response = await fetch('/api/hardware/ddc/freq', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ddc_index: ddcIndex, freq_mhz: freq })
            });

            const data = await response.json();
            if (response.ok && data.success) {
                console.log(`DDC ${ddcIndex} frequency set to ${freq} MHz`);

                // If DDC 0, update FFT center frequency and X-axis
                if (ddcIndex === 0) {
                    updateFFTFrequencyAxis(freq);
                }
            } else {
                alert(`Failed to set DDC ${ddcIndex} frequency: ${data.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Failed to update DDC frequency:', error);
            alert('Failed to update DDC frequency');
        }
    }

    // Update FFT X-axis frequency labels and regenerate X-axis data
    function updateFFTFrequencyAxis(centerFreqMHz) {
        CENTER_FREQ_MHZ = centerFreqMHz;
        FREQ_RES_MHZ = IBW_MHZ / FFT_SIZE;

        // Update the FFT X-axis scale input fields
        const minFreq = CENTER_FREQ_MHZ - (IBW_MHZ / 2);
        const maxFreq = CENTER_FREQ_MHZ + (IBW_MHZ / 2);
        document.getElementById('fftXMin').value = minFreq;
        document.getElementById('fftXMax').value = maxFreq;

        // Regenerate X-axis data array for the FFT chart
        if (uplotFFT && dataFFT && dataFFT.length > 0) {
            const xFFT = Array.from({length: FFT_SIZE}, (_, i) => {
                const bin = i - FFT_SIZE / 2;
                return CENTER_FREQ_MHZ + (bin * FREQ_RES_MHZ);
            });
            dataFFT[0] = xFFT;

            // Update the chart scales to match new frequency range
            fftScaleX = { min: minFreq, max: maxFreq };
            uplotFFT.setScale('x', fftScaleX);
        }
    }

    async function updateHWDDCEnable(ddcIndex) {
        const enableBox = document.getElementById(`ddc${ddcIndex}Enable`);
        const enabled = enableBox.checked;

        try {
            const response = await fetch('/api/hardware/ddc/enable', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ddc_index: ddcIndex, enabled: enabled })
            });

            const data = await response.json();
            if (response.ok && data.success) {
                console.log(`DDC ${ddcIndex} ${enabled ? 'enabled' : 'disabled'}`);
            } else {
                alert(`Failed to update DDC ${ddcIndex}: ${data.error || 'Unknown error'}`);
                enableBox.checked = !enabled; // Revert on failure
            }
        } catch (error) {
            console.error('Failed to update DDC enable:', error);
            alert('Failed to update DDC enable');
            enableBox.checked = !enabled; // Revert on failure
        }
    }

    async function updateHWAttenuation() {
        const attenuationSlider = document.getElementById('attenuationSlider');
        const attenuation = parseInt(attenuationSlider.value);

        try {
            const response = await fetch('/api/hardware/attenuation', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ attenuation_db: attenuation })
            });

            const data = await response.json();
            if (response.ok && data.success) {
                console.log(`Attenuation set to ${attenuation} dB`);
            } else {
                alert(`Failed to set attenuation: ${data.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Failed to update attenuation:', error);
            alert('Failed to update attenuation');
        }
    }

    async function updateHWFilter() {
        const filterSelect = document.getElementById('filterSelect');
        const filter = filterSelect.value;

        try {
            const response = await fetch('/api/hardware/filter', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filter: filter })
            });

            const data = await response.json();
            if (response.ok && data.success) {
                console.log(`Filter set to ${filter}`);
            } else {
                alert(`Failed to set filter: ${data.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Failed to update filter:', error);
            alert('Failed to update filter');
        }
    }

    async function updateHWCalibration() {
        const calBox = document.getElementById('calibrationMode');
        const enabled = calBox.checked;

        try {
            const response = await fetch('/api/hardware/calibration', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            });

            const data = await response.json();
            if (response.ok && data.success) {
                console.log(`Calibration mode ${enabled ? 'enabled' : 'disabled'}`);
            } else {
                alert(`Failed to update calibration mode: ${data.error || 'Unknown error'}`);
                calBox.checked = !enabled; // Revert on failure
            }
        } catch (error) {
            console.error('Failed to update calibration mode:', error);
            alert('Failed to update calibration mode');
            calBox.checked = !enabled; // Revert on failure
        }
    }

    async function toggleHWSystem() {
        const btn = document.getElementById('systemEnableBtn');
        const isCurrentlyOn = btn.innerText.includes("ON");
        const newState = !isCurrentlyOn;

        try {
            const response = await fetch('/api/hardware/system', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: newState })
            });

            const data = await response.json();
            if (response.ok && data.success) {
                if (newState) {
                    btn.innerText = "System: ON";
                    btn.className = "btn-success";
                } else {
                    btn.innerText = "System: OFF";
                    btn.className = "btn-danger";
                }
            } else {
                alert(`Failed to toggle system: ${data.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Failed to toggle system:', error);
            alert('Failed to toggle system');
        }
    }

    async function fetchHardwareState() {
        try {
            const response = await fetch('/api/hardware/state');
            if (!response.ok) return;

            const data = await response.json();

            // Update DDC controls (only if not currently focused/being edited)
            const ddc0Input = document.getElementById('ddc0FreqInput');
            if (document.activeElement !== ddc0Input) {
                ddc0Input.value = data.ddc0_freq_mhz || 0;
            }

            const ddc1Input = document.getElementById('ddc1FreqInput');
            if (document.activeElement !== ddc1Input) {
                ddc1Input.value = data.ddc1_freq_mhz || 0;
            }

            const ddc2Input = document.getElementById('ddc2FreqInput');
            if (document.activeElement !== ddc2Input) {
                ddc2Input.value = data.ddc2_freq_mhz || 0;
            }

            // Update FFT center frequency if DDC0 frequency changed
            const newCenterFreq = data.ddc0_freq_mhz || 0;
            if (CENTER_FREQ_MHZ !== newCenterFreq && uplotFFT) {
                updateFFTFrequencyAxis(newCenterFreq);
            }

            document.getElementById('ddc0Enable').checked = data.ddc0_enabled || false;
            document.getElementById('ddc1Enable').checked = data.ddc1_enabled || false;
            document.getElementById('ddc2Enable').checked = data.ddc2_enabled || false;

            // Update attenuation (only if slider not being dragged)
            const attenSlider = document.getElementById('attenuationSlider');
            const atten = data.attenuation_db || 0;
            if (document.activeElement !== attenSlider) {
                attenSlider.value = atten;
            }
            document.getElementById('attenVal').innerText = atten;

            // Update filter
            document.getElementById('filterSelect').value = data.active_filter || '500mhz';

            // Update calibration
            document.getElementById('calibrationMode').checked = data.cal_enabled || false;

            // Update system enable
            const sysBtn = document.getElementById('systemEnableBtn');
            if (data.system_enabled) {
                sysBtn.innerText = "System: ON";
                sysBtn.className = "btn-success";
            } else {
                sysBtn.innerText = "System: OFF";
                sysBtn.className = "btn-danger";
            }
        } catch (error) {
            // Silent fail to avoid spam
        }
    }

    // --- Recording Logic ---
    let isRecording = false;

    function updateRecordPlaceholder() {
        const mode = document.getElementById('recordMode').value;
        const input = document.getElementById('recordValue');
        if (mode === 'samples') input.placeholder = 'Count (e.g. 100000)';
        else if (mode === 'time') input.placeholder = 'Duration (e.g. 10s)';
        else if (mode === 'size') input.placeholder = 'Size (e.g. 1GB)';
    }

    async function toggleRecording() {
        if (isRecording) {
            // Stop
             try {
                await fetch('/api/record/stop', { method: 'POST' });
            } catch (e) {
                console.error(e);
            }
        } else {
            // Start
            const mode = document.getElementById('recordMode').value;
            const valStr = document.getElementById('recordValue').value;
            
            if (!valStr) {
                alert("Please enter a value");
                return;
            }

            try {
                const res = await fetch('/api/record/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        mode: mode, 
                        value: valStr,
                        samples: 0 // Server will calculate
                    })
                });
                const data = await res.json();
                if (!res.ok) {
                    alert(data.error || "Failed to start recording");
                }
            } catch (e) {
                console.error(e);
            }
        }
    }

    function updateRecordingUI(recording, filename, current, total) {
        isRecording = recording;
        const btn = document.getElementById('recordBtn');
        const status = document.getElementById('recordStatus');
        const bar = document.getElementById('recordProgress');

        if (recording) {
            btn.innerText = "Stop";
            btn.className = "btn-danger";
            btn.style.background = "#e6194b";
            if (filename) status.innerText = `Recording: ${filename}`;
            
            if (total > 0) {
                const pct = (current / total) * 100;
                bar.style.width = pct + "%";
            }
        } else {
            btn.innerText = "Record";
            btn.className = "btn-primary";
            btn.style.background = "#4363d8"; // Restore primary color
            status.innerText = "Ready";
            bar.style.width = "0%";
            
            // Refresh file list if we just finished
            if (filename) {
                fetchReplayFiles();
            }
        }
    }

    // --- Replay Mode Functions ---
    let replayModeActive = false;
    let replayFiles = [];
    let selectedReplayFile = '';
    let isSeeking = false;

    function onSeekInput(val) {
        isSeeking = true;
        const pct = val / 10;
        document.getElementById('replayCurrentTime').innerText = pct.toFixed(1) + "%";
    }

    function onSeekChange(val) {
        isSeeking = false;
        const pct = val / 1000.0;
        seekReplay(pct);
    }

    async function jumpToSample() {
        const val = parseInt(document.getElementById('replaySampleInput').value);
        if (isNaN(val) || val < 0) return;
        
        try {
            await fetch('/api/replay/seek', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sample: val })
            });
        } catch (e) {
            console.error("Jump to sample failed", e);
        }
    }

    async function seekReplay(position) {
        try {
            await fetch('/api/replay/seek', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ position: position })
            });
        } catch (e) {
            console.error("Seek failed", e);
        }
    }

    async function uploadReplayFile() {
        const fileInput = document.getElementById('replayFileInput');
        const statusEl = document.getElementById('replayUploadStatus');

        if (!fileInput.files || fileInput.files.length === 0) {
            statusEl.innerText = 'Please select a file first';
            statusEl.style.color = '#e6194b';
            return;
        }

        const file = fileInput.files[0];
        statusEl.innerText = `Uploading ${file.name}...`;
        statusEl.style.color = 'yellow';

        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/replay/upload', {
                method: 'POST',
                body: formData
            });

            const data = await response.json();

            if (response.ok && data.success) {
                statusEl.innerText = `Uploaded: ${data.filename}`;
                statusEl.style.color = '#3cb44b';
                fileInput.value = ''; // Clear the input
                setTimeout(() => { statusEl.innerText = ''; }, 3000);
            } else {
                statusEl.innerText = `Error: ${data.error || 'Upload failed'}`;
                statusEl.style.color = '#e6194b';
            }
        } catch (error) {
            statusEl.innerText = `Error: ${error.message}`;
            statusEl.style.color = '#e6194b';
        }
    }

    async function fetchReplayFiles() {
        try {
            const response = await fetch('/api/replay/files');
            const data = await response.json();
            updateFileList(data.files || []);
        } catch (error) {
            console.error('Failed to fetch replay files:', error);
        }
    }

    async function selectReplayFile(filename) {
        try {
            const response = await fetch('/api/replay/select', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filename: filename })
            });

            if (!response.ok) {
                const data = await response.json();
                alert(data.error || 'Failed to select file');
            } else {
                // Manually fetch state to ensure UI updates
                fetchReplayState();
            }
        } catch (error) {
            console.error('Failed to select replay file:', error);
        }
    }

    async function deleteReplayFile(filename) {
        if (!confirm(`Delete ${filename}?`)) return;

        try {
            const response = await fetch('/api/replay/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filename: filename })
            });

            if (!response.ok) {
                const data = await response.json();
                alert(data.error || 'Failed to delete file');
            }
        } catch (error) {
            console.error('Failed to delete replay file:', error);
        }
    }

    async function toggleReplayMode() {
        const newState = !replayModeActive;

        try {
            const response = await fetch('/api/replay/toggle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: newState })
            });

            if (!response.ok) {
                const data = await response.json();
                alert(data.error || 'Failed to toggle replay mode');
            }
        } catch (error) {
            console.error('Failed to toggle replay mode:', error);
        }
    }

    async function clearReplaySelection() {
        try {
            const response = await fetch('/api/replay/clear', {
                method: 'POST'
            });

            if (response.ok) {
                updateReplayUI(false, '', 0, false);
            }
        } catch (error) {
            console.error('Failed to clear replay selection:', error);
        }
    }

    async function fetchReplayState() {
        try {
            const response = await fetch('/api/replay/state');
            const data = await response.json();
            updateReplayUI(data.has_data, data.filename, data.size, data.replay_mode);
        } catch (error) {
            console.error('Failed to fetch replay state:', error);
        }
    }

    function updateFileList(files) {
        replayFiles = files;
        const listEl = document.getElementById('replayFileList');

        if (files.length === 0) {
            listEl.innerHTML = '<div style="color: #666; font-size: 12px;">No files uploaded</div>';
            return;
        }

        let html = '';
        files.forEach(file => {
            const isSelected = file.name === selectedReplayFile;
            const bgColor = isSelected ? '#3d3d3d' : 'transparent';
            const border = isSelected ? '1px solid #4363d8' : '1px solid #333';
            const textColor = isSelected ? '#fff' : '#ccc';
            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 5px 8px; margin: 2px 0; background: ${bgColor}; border: ${border}; border-radius: 3px; font-size: 12px;">
                    <div style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: ${textColor};" title="${file.name}">
                        ${file.name}
                    </div>
                    <div style="color: #888; margin: 0 8px; white-space: nowrap; font-size: 11px;">${formatBytes(file.size)}</div>
                    <button onclick="selectReplayFile('${file.name}')" style="background: #4363d8; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; margin-right: 5px; width: auto; margin-bottom: 0;">Select</button>
                    <button onclick="deleteReplayFile('${file.name}')" style="background: #e6194b; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; font-weight: bold; width: auto; margin-bottom: 0;">X</button>
                </div>
            `;
        });
        listEl.innerHTML = html;
    }

    function updateReplayUI(hasData, filename, size, isReplayingState) {
        replayModeActive = isReplayingState;
        isReplaying = isReplayingState; // Update global state
        selectedReplayFile = filename;

        const fileNameEl = document.getElementById('replayFileName');
        const fileSizeEl = document.getElementById('replayFileSize');
        // Removed old status elements and buttons from here since they are gone/moved

        fileNameEl.innerText = hasData ? filename : 'None';
        fileSizeEl.innerText = hasData ? formatBytes(size) : '--';

        // Update the Main Transport Button
        updateTransportButton();

        // Update file list to show selection
        updateFileList(replayFiles);

        if (hasData) {
            // Calculate total samples from size
            const totalSamples = Math.floor(size / 32);
            document.getElementById('replaySampleTotal').innerText = `Total: ${totalSamples}`;
        } else {
            const slider = document.getElementById('replaySeek');
            if (slider) {
                slider.value = 0;
                document.getElementById('replayCurrentTime').innerText = "0%";
            }
            document.getElementById('replaySampleInput').value = '';
            document.getElementById('replaySampleTotal').innerText = 'Total: 0';
        }
    }

    function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // --- WebSocket ---
    function connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
        ws.binaryType = 'arraybuffer';

        ws.onopen = () => {
            document.getElementById('connectionStatus').innerText = "SYSTEM CONNECTED";
            document.getElementById('connectionStatus').style.color = "#3cb44b";
            updateConfig(); 
        };

        ws.onmessage = (event) => {
            if (typeof event.data === "string") {
                try {
                    const msg = JSON.parse(event.data);
                    
                    if (msg.type === "ddc_freq_update") {
                        // Handle DDC frequency update from hardware (e.g., on stream start)
                        if (msg.ddc_index === 0) {
                            document.getElementById('ddc0FreqInput').value = msg.freq_mhz;
                            updateFFTFrequencyAxis(msg.freq_mhz);
                        } else if (msg.ddc_index === 1) {
                            document.getElementById('ddc1FreqInput').value = msg.freq_mhz;
                        } else if (msg.ddc_index === 2) {
                            document.getElementById('ddc2FreqInput').value = msg.freq_mhz;
                        }
                    } else if (msg.type === "siggen_freq_update") {
                        document.getElementById('sigGenFreqInput').value = msg.freq_mhz;
                    } else if (msg.type === "siggen_power_update") {
                        document.getElementById('sigGenPowerInput').value = msg.power_dbm;
                    } else if (msg.type === "siggen_output_update") {
                        const btn = document.getElementById('sigGenToggle');
                        if (msg.enabled) {
                            btn.innerText = "RF Output: ON";
                            btn.className = "btn-success";
                        } else {
                            btn.innerText = "RF Output: OFF";
                            btn.className = "btn-danger";
                        }
                    } else if (msg.type === "sweep_status") {
                         if (msg.running) {
                             setSweepRunningState(true);
                             if (msg.params) {
                                 document.getElementById('sweepStart').value = msg.params.start_mhz;
                                 document.getElementById('sweepStop').value = msg.params.stop_mhz;
                                 document.getElementById('sweepStep').value = msg.params.step_mhz;
                                 document.getElementById('sweepDwell').value = msg.params.dwell_ms;
                             }
                         } else {
                             setSweepRunningState(false);
                         }
                    } else if (msg.type === "sweep_progress") {
                        document.getElementById('sigGenFreqInput').value = msg.freq_mhz.toFixed(3);
                    } else if (msg.type === "replay_update") {
                        updateReplayUI(msg.has_data, msg.filename || '', msg.size || 0, msg.replay_mode);
                    } else if (msg.type === "replay_files") {
                        updateFileList(msg.files || []);
                    } else if (msg.type === "replay_progress") {
                        if (!isSeeking) {
                            const slider = document.getElementById('replaySeek');
                            if (slider) {
                                slider.value = msg.progress * 1000;
                                document.getElementById('replayCurrentTime').innerText = (msg.progress * 100).toFixed(1) + "%";
                            }
                        }
                        const currentSample = Math.floor(msg.offset / 32);
                        const totalSamples = Math.floor(msg.total / 32);
                        document.getElementById('replaySampleInput').value = currentSample;
                        document.getElementById('replaySampleTotal').innerText = `Total: ${totalSamples}`;
                    } else if (msg.type === "recording_status") {
                        updateRecordingUI(msg.recording, msg.filename, msg.current, msg.total);
                        if (!msg.recording && msg.finished) {
                            alert("Recording Finished");
                            fetchReplayFiles();
                        }
                    } else if (msg.type === "recording_progress") {
                        const bar = document.getElementById('recordProgress');
                        const pct = (msg.current / msg.total) * 100;
                        bar.style.width = pct + "%";
                    }
                } catch (e) {
                     console.error("Parse error:", e);
                }
            } else {
                parseAndPlot(event.data);
            }
        };
        
        ws.onclose = () => {
            document.getElementById('connectionStatus').innerText = "CONNECTION LOST - RECONNECTING...";
            document.getElementById('connectionStatus').style.color = "#e6194b";
            setTimeout(connect, 2000);
        };
    }

    // Initialize
    fetchRFConfig().then(() => {
        setupCharts();
        connect();
    });

    // Fetch initial values
    fetchSigGenState();
    fetchPSUState(); // Initial fetch
    fetchSweepState();
    fetchReplayFiles(); // Initial file list fetch
    fetchReplayState(); // Initial replay state fetch
    fetchHardwareState(); // Initial hardware state fetch
    setInterval(fetchPSUState, 2000); // Poll every 2 seconds
    setInterval(fetchHardwareState, 2000); // Poll hardware state every 2 seconds

    window.addEventListener('resize', () => {
        const w = getChartWidth();
        if(uplotTime) uplotTime.setSize({width: w, height: 300});
        if(uplotFFT) uplotFFT.setSize({width: w, height: 500});
    });

</script>
{{ end }}